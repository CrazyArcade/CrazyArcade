// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_API_API_H_
#define FLATBUFFERS_GENERATED_API_API_H_

#include "flatbuffers/flatbuffers.h"

namespace API
{

    struct UserData;

    struct Welcome;

    struct GotIt;

    struct JoinRoom;

    struct RoomInfoUpdate;

    struct UserChangeRole;

    struct UserChangeStats;

    struct PlayerData;

    struct GameInit;

    struct PlayerPosChange;

    struct PlayerSetBubble;

    struct BubbleSet;

    struct BubbleBoom;

    struct PropSet;

    struct PlayerEatProp;

    struct PlayerAttrChange;

    struct PlayerStatusChange;

    struct GameStatusChange;

    struct Msg;

    enum MsgType
    {
        MsgType_NONE = 0,
        MsgType_Welcome = 1,
        MsgType_GotIt = 2,
        MsgType_JoinRoom = 3,
        MsgType_RoomInfoUpdate = 4,
        MsgType_UserChangeRole = 5,
        MsgType_UserChangeStats = 6,
        MsgType_GameInit = 7,
        MsgType_PlayerPosChange = 8,
        MsgType_PlayerSetBubble = 9,
        MsgType_BubbleSet = 10,
        MsgType_BubbleBoom = 11,
        MsgType_PropSet = 12,
        MsgType_PlayerEatProp = 13,
        MsgType_PlayerAttrChange = 14,
        MsgType_PlayerStatusChange = 15,
        MsgType_GameStatusChange = 16,
        MsgType_MIN = MsgType_NONE,
        MsgType_MAX = MsgType_GameStatusChange
    };

    inline const char **EnumNamesMsgType()
    {
        static const char *names[] = { "NONE", "Welcome", "GotIt", "JoinRoom", "RoomInfoUpdate", "UserChangeRole", "UserChangeStats", "GameInit", "PlayerPosChange", "PlayerSetBubble", "BubbleSet", "BubbleBoom", "PropSet", "PlayerEatProp", "PlayerAttrChange", "PlayerStatusChange", "GameStatusChange", nullptr };
        return names;
    }

    inline const char *EnumNameMsgType(MsgType e) { return EnumNamesMsgType()[static_cast<int>(e)]; }

    template<typename T> struct MsgTypeTraits
    {
        static const MsgType enum_value = MsgType_NONE;
    };

    template<> struct MsgTypeTraits<Welcome>
    {
        static const MsgType enum_value = MsgType_Welcome;
    };

    template<> struct MsgTypeTraits<GotIt>
    {
        static const MsgType enum_value = MsgType_GotIt;
    };

    template<> struct MsgTypeTraits<JoinRoom>
    {
        static const MsgType enum_value = MsgType_JoinRoom;
    };

    template<> struct MsgTypeTraits<RoomInfoUpdate>
    {
        static const MsgType enum_value = MsgType_RoomInfoUpdate;
    };

    template<> struct MsgTypeTraits<UserChangeRole>
    {
        static const MsgType enum_value = MsgType_UserChangeRole;
    };

    template<> struct MsgTypeTraits<UserChangeStats>
    {
        static const MsgType enum_value = MsgType_UserChangeStats;
    };

    template<> struct MsgTypeTraits<GameInit>
    {
        static const MsgType enum_value = MsgType_GameInit;
    };

    template<> struct MsgTypeTraits<PlayerPosChange>
    {
        static const MsgType enum_value = MsgType_PlayerPosChange;
    };

    template<> struct MsgTypeTraits<PlayerSetBubble>
    {
        static const MsgType enum_value = MsgType_PlayerSetBubble;
    };

    template<> struct MsgTypeTraits<BubbleSet>
    {
        static const MsgType enum_value = MsgType_BubbleSet;
    };

    template<> struct MsgTypeTraits<BubbleBoom>
    {
        static const MsgType enum_value = MsgType_BubbleBoom;
    };

    template<> struct MsgTypeTraits<PropSet>
    {
        static const MsgType enum_value = MsgType_PropSet;
    };

    template<> struct MsgTypeTraits<PlayerEatProp>
    {
        static const MsgType enum_value = MsgType_PlayerEatProp;
    };

    template<> struct MsgTypeTraits<PlayerAttrChange>
    {
        static const MsgType enum_value = MsgType_PlayerAttrChange;
    };

    template<> struct MsgTypeTraits<PlayerStatusChange>
    {
        static const MsgType enum_value = MsgType_PlayerStatusChange;
    };

    template<> struct MsgTypeTraits<GameStatusChange>
    {
        static const MsgType enum_value = MsgType_GameStatusChange;
    };

    inline bool VerifyMsgType(flatbuffers::Verifier &verifier, const void *union_obj, MsgType type);

    enum Direction
    {
        Direction_LEFT = 0,
        Direction_RIGHT = 1,
        Direction_UP = 2,
        Direction_DOWN = 3,
        Direction_NONE = 4,
        Direction_MIN = Direction_LEFT,
        Direction_MAX = Direction_NONE
    };

    inline const char **EnumNamesDirection()
    {
        static const char *names[] = { "LEFT", "RIGHT", "UP", "DOWN", "NONE", nullptr };
        return names;
    }

    inline const char *EnumNameDirection(Direction e) { return EnumNamesDirection()[static_cast<int>(e)]; }

    enum PropType
    {
        PropType_NONE = 0,
        PropType_SPEED_UP = 100,
        PropType_BUBBLE_UP = 101,
        PropType_DAMAGE_UP = 102,
        PropType_MIN = PropType_NONE,
        PropType_MAX = PropType_DAMAGE_UP
    };

    enum PlayerStatus
    {
        PlayerStatus_FREE = 0,
        PlayerStatus_FREEZE = 1,
        PlayerStatus_DIE = 2,
        PlayerStatus_MIN = PlayerStatus_FREE,
        PlayerStatus_MAX = PlayerStatus_DIE
    };

    inline const char **EnumNamesPlayerStatus()
    {
        static const char *names[] = { "FREE", "FREEZE", "DIE", nullptr };
        return names;
    }

    inline const char *EnumNamePlayerStatus(PlayerStatus e) { return EnumNamesPlayerStatus()[static_cast<int>(e)]; }

    enum GameStatus
    {
        GameStatus_WAITING = 0,
        GameStatus_PENDING = 1,
        GameStatus_START = 2,
        GameStatus_OVER = 3,
        GameStatus_MIN = GameStatus_WAITING,
        GameStatus_MAX = GameStatus_OVER
    };

    inline const char **EnumNamesGameStatus()
    {
        static const char *names[] = { "WAITING", "PENDING", "START", "OVER", nullptr };
        return names;
    }

    inline const char *EnumNameGameStatus(GameStatus e) { return EnumNamesGameStatus()[static_cast<int>(e)]; }

    struct UserData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
    {
        enum
        {
            VT_UID = 4,
            VT_NAME = 6,
            VT_ROLE = 8
        };
        const flatbuffers::String *uid() const { return GetPointer<const flatbuffers::String *>(VT_UID); }
        const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(VT_NAME); }
        int32_t role() const { return GetField<int32_t>(VT_ROLE, 0); }
        bool Verify(flatbuffers::Verifier &verifier) const
        {
            return VerifyTableStart(verifier) &&
                VerifyField<flatbuffers::uoffset_t>(verifier, VT_UID) &&
                verifier.Verify(uid()) &&
                VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
                verifier.Verify(name()) &&
                VerifyField<int32_t>(verifier, VT_ROLE) &&
                verifier.EndTable();
        }
    };

    struct UserDataBuilder
    {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_uid(flatbuffers::Offset<flatbuffers::String> uid) { fbb_.AddOffset(UserData::VT_UID, uid); }
        void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(UserData::VT_NAME, name); }
        void add_role(int32_t role) { fbb_.AddElement<int32_t>(UserData::VT_ROLE, role, 0); }
        UserDataBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
        UserDataBuilder &operator=(const UserDataBuilder &);
        flatbuffers::Offset<UserData> Finish()
        {
            auto o = flatbuffers::Offset<UserData>(fbb_.EndTable(start_, 3));
            return o;
        }
    };

    inline flatbuffers::Offset<UserData> CreateUserData(flatbuffers::FlatBufferBuilder &_fbb,
        flatbuffers::Offset<flatbuffers::String> uid = 0,
        flatbuffers::Offset<flatbuffers::String> name = 0,
        int32_t role = 0)
    {
        UserDataBuilder builder_(_fbb);
        builder_.add_role(role);
        builder_.add_name(name);
        builder_.add_uid(uid);
        return builder_.Finish();
    }

    inline flatbuffers::Offset<UserData> CreateUserDataDirect(flatbuffers::FlatBufferBuilder &_fbb,
        const char *uid = nullptr,
        const char *name = nullptr,
        int32_t role = 0)
    {
        return CreateUserData(_fbb, uid ? _fbb.CreateString(uid) : 0, name ? _fbb.CreateString(name) : 0, role);
    }

    struct Welcome FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
    {
        enum
        {
            VT_UID = 4
        };
        const flatbuffers::String *uid() const { return GetPointer<const flatbuffers::String *>(VT_UID); }
        bool Verify(flatbuffers::Verifier &verifier) const
        {
            return VerifyTableStart(verifier) &&
                VerifyField<flatbuffers::uoffset_t>(verifier, VT_UID) &&
                verifier.Verify(uid()) &&
                verifier.EndTable();
        }
    };

    struct WelcomeBuilder
    {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_uid(flatbuffers::Offset<flatbuffers::String> uid) { fbb_.AddOffset(Welcome::VT_UID, uid); }
        WelcomeBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
        WelcomeBuilder &operator=(const WelcomeBuilder &);
        flatbuffers::Offset<Welcome> Finish()
        {
            auto o = flatbuffers::Offset<Welcome>(fbb_.EndTable(start_, 1));
            return o;
        }
    };

    inline flatbuffers::Offset<Welcome> CreateWelcome(flatbuffers::FlatBufferBuilder &_fbb,
        flatbuffers::Offset<flatbuffers::String> uid = 0)
    {
        WelcomeBuilder builder_(_fbb);
        builder_.add_uid(uid);
        return builder_.Finish();
    }

    inline flatbuffers::Offset<Welcome> CreateWelcomeDirect(flatbuffers::FlatBufferBuilder &_fbb,
        const char *uid = nullptr)
    {
        return CreateWelcome(_fbb, uid ? _fbb.CreateString(uid) : 0);
    }

    struct GotIt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
    {
        enum
        {
            VT_NAME = 4
        };
        const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(VT_NAME); }
        bool Verify(flatbuffers::Verifier &verifier) const
        {
            return VerifyTableStart(verifier) &&
                VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
                verifier.Verify(name()) &&
                verifier.EndTable();
        }
    };

    struct GotItBuilder
    {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(GotIt::VT_NAME, name); }
        GotItBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
        GotItBuilder &operator=(const GotItBuilder &);
        flatbuffers::Offset<GotIt> Finish()
        {
            auto o = flatbuffers::Offset<GotIt>(fbb_.EndTable(start_, 1));
            return o;
        }
    };

    inline flatbuffers::Offset<GotIt> CreateGotIt(flatbuffers::FlatBufferBuilder &_fbb,
        flatbuffers::Offset<flatbuffers::String> name = 0)
    {
        GotItBuilder builder_(_fbb);
        builder_.add_name(name);
        return builder_.Finish();
    }

    inline flatbuffers::Offset<GotIt> CreateGotItDirect(flatbuffers::FlatBufferBuilder &_fbb,
        const char *name = nullptr)
    {
        return CreateGotIt(_fbb, name ? _fbb.CreateString(name) : 0);
    }

    struct JoinRoom FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
    {
        bool Verify(flatbuffers::Verifier &verifier) const
        {
            return VerifyTableStart(verifier) &&
                verifier.EndTable();
        }
    };

    struct JoinRoomBuilder
    {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        JoinRoomBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
        JoinRoomBuilder &operator=(const JoinRoomBuilder &);
        flatbuffers::Offset<JoinRoom> Finish()
        {
            auto o = flatbuffers::Offset<JoinRoom>(fbb_.EndTable(start_, 0));
            return o;
        }
    };

    inline flatbuffers::Offset<JoinRoom> CreateJoinRoom(flatbuffers::FlatBufferBuilder &_fbb)
    {
        JoinRoomBuilder builder_(_fbb);
        return builder_.Finish();
    }

    struct RoomInfoUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
    {
        enum
        {
            VT_USERS = 4
        };
        const flatbuffers::Vector<flatbuffers::Offset<UserData>> *users() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<UserData>> *>(VT_USERS); }
        bool Verify(flatbuffers::Verifier &verifier) const
        {
            return VerifyTableStart(verifier) &&
                VerifyField<flatbuffers::uoffset_t>(verifier, VT_USERS) &&
                verifier.Verify(users()) &&
                verifier.VerifyVectorOfTables(users()) &&
                verifier.EndTable();
        }
    };

    struct RoomInfoUpdateBuilder
    {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_users(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UserData>>> users) { fbb_.AddOffset(RoomInfoUpdate::VT_USERS, users); }
        RoomInfoUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
        RoomInfoUpdateBuilder &operator=(const RoomInfoUpdateBuilder &);
        flatbuffers::Offset<RoomInfoUpdate> Finish()
        {
            auto o = flatbuffers::Offset<RoomInfoUpdate>(fbb_.EndTable(start_, 1));
            return o;
        }
    };

    inline flatbuffers::Offset<RoomInfoUpdate> CreateRoomInfoUpdate(flatbuffers::FlatBufferBuilder &_fbb,
        flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UserData>>> users = 0)
    {
        RoomInfoUpdateBuilder builder_(_fbb);
        builder_.add_users(users);
        return builder_.Finish();
    }

    inline flatbuffers::Offset<RoomInfoUpdate> CreateRoomInfoUpdateDirect(flatbuffers::FlatBufferBuilder &_fbb,
        const std::vector<flatbuffers::Offset<UserData>> *users = nullptr)
    {
        return CreateRoomInfoUpdate(_fbb, users ? _fbb.CreateVector<flatbuffers::Offset<UserData>>(*users) : 0);
    }

    struct UserChangeRole FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
    {
        enum
        {
            VT_ROLE = 4
        };
        int32_t role() const { return GetField<int32_t>(VT_ROLE, 0); }
        bool Verify(flatbuffers::Verifier &verifier) const
        {
            return VerifyTableStart(verifier) &&
                VerifyField<int32_t>(verifier, VT_ROLE) &&
                verifier.EndTable();
        }
    };

    struct UserChangeRoleBuilder
    {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_role(int32_t role) { fbb_.AddElement<int32_t>(UserChangeRole::VT_ROLE, role, 0); }
        UserChangeRoleBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
        UserChangeRoleBuilder &operator=(const UserChangeRoleBuilder &);
        flatbuffers::Offset<UserChangeRole> Finish()
        {
            auto o = flatbuffers::Offset<UserChangeRole>(fbb_.EndTable(start_, 1));
            return o;
        }
    };

    inline flatbuffers::Offset<UserChangeRole> CreateUserChangeRole(flatbuffers::FlatBufferBuilder &_fbb,
        int32_t role = 0)
    {
        UserChangeRoleBuilder builder_(_fbb);
        builder_.add_role(role);
        return builder_.Finish();
    }

    struct UserChangeStats FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
    {
        enum
        {
            VT_STAT = 4
        };
        int32_t stat() const { return GetField<int32_t>(VT_STAT, 0); }
        bool Verify(flatbuffers::Verifier &verifier) const
        {
            return VerifyTableStart(verifier) &&
                VerifyField<int32_t>(verifier, VT_STAT) &&
                verifier.EndTable();
        }
    };

    struct UserChangeStatsBuilder
    {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_stat(int32_t stat) { fbb_.AddElement<int32_t>(UserChangeStats::VT_STAT, stat, 0); }
        UserChangeStatsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
        UserChangeStatsBuilder &operator=(const UserChangeStatsBuilder &);
        flatbuffers::Offset<UserChangeStats> Finish()
        {
            auto o = flatbuffers::Offset<UserChangeStats>(fbb_.EndTable(start_, 1));
            return o;
        }
    };

    inline flatbuffers::Offset<UserChangeStats> CreateUserChangeStats(flatbuffers::FlatBufferBuilder &_fbb,
        int32_t stat = 0)
    {
        UserChangeStatsBuilder builder_(_fbb);
        builder_.add_stat(stat);
        return builder_.Finish();
    }

    struct PlayerData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
    {
        enum
        {
            VT_ID = 4,
            VT_X = 6,
            VT_Y = 8,
            VT_ROLE = 10
        };
        const flatbuffers::String *id() const { return GetPointer<const flatbuffers::String *>(VT_ID); }
        int32_t x() const { return GetField<int32_t>(VT_X, 0); }
        int32_t y() const { return GetField<int32_t>(VT_Y, 0); }
        int32_t role() const { return GetField<int32_t>(VT_ROLE, 0); }
        bool Verify(flatbuffers::Verifier &verifier) const
        {
            return VerifyTableStart(verifier) &&
                VerifyField<flatbuffers::uoffset_t>(verifier, VT_ID) &&
                verifier.Verify(id()) &&
                VerifyField<int32_t>(verifier, VT_X) &&
                VerifyField<int32_t>(verifier, VT_Y) &&
                VerifyField<int32_t>(verifier, VT_ROLE) &&
                verifier.EndTable();
        }
    };

    struct PlayerDataBuilder
    {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_id(flatbuffers::Offset<flatbuffers::String> id) { fbb_.AddOffset(PlayerData::VT_ID, id); }
        void add_x(int32_t x) { fbb_.AddElement<int32_t>(PlayerData::VT_X, x, 0); }
        void add_y(int32_t y) { fbb_.AddElement<int32_t>(PlayerData::VT_Y, y, 0); }
        void add_role(int32_t role) { fbb_.AddElement<int32_t>(PlayerData::VT_ROLE, role, 0); }
        PlayerDataBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
        PlayerDataBuilder &operator=(const PlayerDataBuilder &);
        flatbuffers::Offset<PlayerData> Finish()
        {
            auto o = flatbuffers::Offset<PlayerData>(fbb_.EndTable(start_, 4));
            return o;
        }
    };

    inline flatbuffers::Offset<PlayerData> CreatePlayerData(flatbuffers::FlatBufferBuilder &_fbb,
        flatbuffers::Offset<flatbuffers::String> id = 0,
        int32_t x = 0,
        int32_t y = 0,
        int32_t role = 0)
    {
        PlayerDataBuilder builder_(_fbb);
        builder_.add_role(role);
        builder_.add_y(y);
        builder_.add_x(x);
        builder_.add_id(id);
        return builder_.Finish();
    }

    inline flatbuffers::Offset<PlayerData> CreatePlayerDataDirect(flatbuffers::FlatBufferBuilder &_fbb,
        const char *id = nullptr,
        int32_t x = 0,
        int32_t y = 0,
        int32_t role = 0)
    {
        return CreatePlayerData(_fbb, id ? _fbb.CreateString(id) : 0, x, y, role);
    }

    struct GameInit FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
    {
        enum
        {
            VT_PLAYERS = 4
        };
        const flatbuffers::Vector<flatbuffers::Offset<PlayerData>> *players() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PlayerData>> *>(VT_PLAYERS); }
        bool Verify(flatbuffers::Verifier &verifier) const
        {
            return VerifyTableStart(verifier) &&
                VerifyField<flatbuffers::uoffset_t>(verifier, VT_PLAYERS) &&
                verifier.Verify(players()) &&
                verifier.VerifyVectorOfTables(players()) &&
                verifier.EndTable();
        }
    };

    struct GameInitBuilder
    {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_players(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PlayerData>>> players) { fbb_.AddOffset(GameInit::VT_PLAYERS, players); }
        GameInitBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
        GameInitBuilder &operator=(const GameInitBuilder &);
        flatbuffers::Offset<GameInit> Finish()
        {
            auto o = flatbuffers::Offset<GameInit>(fbb_.EndTable(start_, 1));
            return o;
        }
    };

    inline flatbuffers::Offset<GameInit> CreateGameInit(flatbuffers::FlatBufferBuilder &_fbb,
        flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PlayerData>>> players = 0)
    {
        GameInitBuilder builder_(_fbb);
        builder_.add_players(players);
        return builder_.Finish();
    }

    inline flatbuffers::Offset<GameInit> CreateGameInitDirect(flatbuffers::FlatBufferBuilder &_fbb,
        const std::vector<flatbuffers::Offset<PlayerData>> *players = nullptr)
    {
        return CreateGameInit(_fbb, players ? _fbb.CreateVector<flatbuffers::Offset<PlayerData>>(*players) : 0);
    }

    struct PlayerPosChange FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
    {
        enum
        {
            VT_ID = 4,
            VT_DIRECTION = 6,
            VT_X = 8,
            VT_Y = 10
        };
        const flatbuffers::String *id() const { return GetPointer<const flatbuffers::String *>(VT_ID); }
        Direction direction() const { return static_cast<Direction>(GetField<int8_t>(VT_DIRECTION, 0)); }
        int32_t x() const { return GetField<int32_t>(VT_X, 0); }
        int32_t y() const { return GetField<int32_t>(VT_Y, 0); }
        bool Verify(flatbuffers::Verifier &verifier) const
        {
            return VerifyTableStart(verifier) &&
                VerifyField<flatbuffers::uoffset_t>(verifier, VT_ID) &&
                verifier.Verify(id()) &&
                VerifyField<int8_t>(verifier, VT_DIRECTION) &&
                VerifyField<int32_t>(verifier, VT_X) &&
                VerifyField<int32_t>(verifier, VT_Y) &&
                verifier.EndTable();
        }
    };

    struct PlayerPosChangeBuilder
    {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_id(flatbuffers::Offset<flatbuffers::String> id) { fbb_.AddOffset(PlayerPosChange::VT_ID, id); }
        void add_direction(Direction direction) { fbb_.AddElement<int8_t>(PlayerPosChange::VT_DIRECTION, static_cast<int8_t>(direction), 0); }
        void add_x(int32_t x) { fbb_.AddElement<int32_t>(PlayerPosChange::VT_X, x, 0); }
        void add_y(int32_t y) { fbb_.AddElement<int32_t>(PlayerPosChange::VT_Y, y, 0); }
        PlayerPosChangeBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
        PlayerPosChangeBuilder &operator=(const PlayerPosChangeBuilder &);
        flatbuffers::Offset<PlayerPosChange> Finish()
        {
            auto o = flatbuffers::Offset<PlayerPosChange>(fbb_.EndTable(start_, 4));
            return o;
        }
    };

    inline flatbuffers::Offset<PlayerPosChange> CreatePlayerPosChange(flatbuffers::FlatBufferBuilder &_fbb,
        flatbuffers::Offset<flatbuffers::String> id = 0,
        Direction direction = Direction_LEFT,
        int32_t x = 0,
        int32_t y = 0)
    {
        PlayerPosChangeBuilder builder_(_fbb);
        builder_.add_y(y);
        builder_.add_x(x);
        builder_.add_id(id);
        builder_.add_direction(direction);
        return builder_.Finish();
    }

    inline flatbuffers::Offset<PlayerPosChange> CreatePlayerPosChangeDirect(flatbuffers::FlatBufferBuilder &_fbb,
        const char *id = nullptr,
        Direction direction = Direction_LEFT,
        int32_t x = 0,
        int32_t y = 0)
    {
        return CreatePlayerPosChange(_fbb, id ? _fbb.CreateString(id) : 0, direction, x, y);
    }

    struct PlayerSetBubble FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
    {
        bool Verify(flatbuffers::Verifier &verifier) const
        {
            return VerifyTableStart(verifier) &&
                verifier.EndTable();
        }
    };

    struct PlayerSetBubbleBuilder
    {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        PlayerSetBubbleBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
        PlayerSetBubbleBuilder &operator=(const PlayerSetBubbleBuilder &);
        flatbuffers::Offset<PlayerSetBubble> Finish()
        {
            auto o = flatbuffers::Offset<PlayerSetBubble>(fbb_.EndTable(start_, 0));
            return o;
        }
    };

    inline flatbuffers::Offset<PlayerSetBubble> CreatePlayerSetBubble(flatbuffers::FlatBufferBuilder &_fbb)
    {
        PlayerSetBubbleBuilder builder_(_fbb);
        return builder_.Finish();
    }

    struct BubbleSet FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
    {
        enum
        {
            VT_ID = 4,
            VT_PLAYER_ID = 6,
            VT_X = 8,
            VT_Y = 10,
            VT_DAMAGE = 12
        };
        const flatbuffers::String *id() const { return GetPointer<const flatbuffers::String *>(VT_ID); }
        const flatbuffers::String *player_id() const { return GetPointer<const flatbuffers::String *>(VT_PLAYER_ID); }
        int32_t x() const { return GetField<int32_t>(VT_X, 0); }
        int32_t y() const { return GetField<int32_t>(VT_Y, 0); }
        uint8_t damage() const { return GetField<uint8_t>(VT_DAMAGE, 0); }
        bool Verify(flatbuffers::Verifier &verifier) const
        {
            return VerifyTableStart(verifier) &&
                VerifyField<flatbuffers::uoffset_t>(verifier, VT_ID) &&
                verifier.Verify(id()) &&
                VerifyField<flatbuffers::uoffset_t>(verifier, VT_PLAYER_ID) &&
                verifier.Verify(player_id()) &&
                VerifyField<int32_t>(verifier, VT_X) &&
                VerifyField<int32_t>(verifier, VT_Y) &&
                VerifyField<uint8_t>(verifier, VT_DAMAGE) &&
                verifier.EndTable();
        }
    };

    struct BubbleSetBuilder
    {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_id(flatbuffers::Offset<flatbuffers::String> id) { fbb_.AddOffset(BubbleSet::VT_ID, id); }
        void add_player_id(flatbuffers::Offset<flatbuffers::String> player_id) { fbb_.AddOffset(BubbleSet::VT_PLAYER_ID, player_id); }
        void add_x(int32_t x) { fbb_.AddElement<int32_t>(BubbleSet::VT_X, x, 0); }
        void add_y(int32_t y) { fbb_.AddElement<int32_t>(BubbleSet::VT_Y, y, 0); }
        void add_damage(uint8_t damage) { fbb_.AddElement<uint8_t>(BubbleSet::VT_DAMAGE, damage, 0); }
        BubbleSetBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
        BubbleSetBuilder &operator=(const BubbleSetBuilder &);
        flatbuffers::Offset<BubbleSet> Finish()
        {
            auto o = flatbuffers::Offset<BubbleSet>(fbb_.EndTable(start_, 5));
            return o;
        }
    };

    inline flatbuffers::Offset<BubbleSet> CreateBubbleSet(flatbuffers::FlatBufferBuilder &_fbb,
        flatbuffers::Offset<flatbuffers::String> id = 0,
        flatbuffers::Offset<flatbuffers::String> player_id = 0,
        int32_t x = 0,
        int32_t y = 0,
        uint8_t damage = 0)
    {
        BubbleSetBuilder builder_(_fbb);
        builder_.add_y(y);
        builder_.add_x(x);
        builder_.add_player_id(player_id);
        builder_.add_id(id);
        builder_.add_damage(damage);
        return builder_.Finish();
    }

    inline flatbuffers::Offset<BubbleSet> CreateBubbleSetDirect(flatbuffers::FlatBufferBuilder &_fbb,
        const char *id = nullptr,
        const char *player_id = nullptr,
        int32_t x = 0,
        int32_t y = 0,
        uint8_t damage = 0)
    {
        return CreateBubbleSet(_fbb, id ? _fbb.CreateString(id) : 0, player_id ? _fbb.CreateString(player_id) : 0, x, y, damage);
    }

    struct BubbleBoom FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
    {
        enum
        {
            VT_ID = 4
        };
        const flatbuffers::String *id() const { return GetPointer<const flatbuffers::String *>(VT_ID); }
        bool Verify(flatbuffers::Verifier &verifier) const
        {
            return VerifyTableStart(verifier) &&
                VerifyField<flatbuffers::uoffset_t>(verifier, VT_ID) &&
                verifier.Verify(id()) &&
                verifier.EndTable();
        }
    };

    struct BubbleBoomBuilder
    {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_id(flatbuffers::Offset<flatbuffers::String> id) { fbb_.AddOffset(BubbleBoom::VT_ID, id); }
        BubbleBoomBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
        BubbleBoomBuilder &operator=(const BubbleBoomBuilder &);
        flatbuffers::Offset<BubbleBoom> Finish()
        {
            auto o = flatbuffers::Offset<BubbleBoom>(fbb_.EndTable(start_, 1));
            return o;
        }
    };

    inline flatbuffers::Offset<BubbleBoom> CreateBubbleBoom(flatbuffers::FlatBufferBuilder &_fbb,
        flatbuffers::Offset<flatbuffers::String> id = 0)
    {
        BubbleBoomBuilder builder_(_fbb);
        builder_.add_id(id);
        return builder_.Finish();
    }

    inline flatbuffers::Offset<BubbleBoom> CreateBubbleBoomDirect(flatbuffers::FlatBufferBuilder &_fbb,
        const char *id = nullptr)
    {
        return CreateBubbleBoom(_fbb, id ? _fbb.CreateString(id) : 0);
    }

    struct PropSet FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
    {
        enum
        {
            VT_ID = 4,
            VT_X = 6,
            VT_Y = 8,
            VT_TYPE = 10
        };
        const flatbuffers::String *id() const { return GetPointer<const flatbuffers::String *>(VT_ID); }
        int32_t x() const { return GetField<int32_t>(VT_X, 0); }
        int32_t y() const { return GetField<int32_t>(VT_Y, 0); }
        PropType type() const { return static_cast<PropType>(GetField<int8_t>(VT_TYPE, 0)); }
        bool Verify(flatbuffers::Verifier &verifier) const
        {
            return VerifyTableStart(verifier) &&
                VerifyField<flatbuffers::uoffset_t>(verifier, VT_ID) &&
                verifier.Verify(id()) &&
                VerifyField<int32_t>(verifier, VT_X) &&
                VerifyField<int32_t>(verifier, VT_Y) &&
                VerifyField<int8_t>(verifier, VT_TYPE) &&
                verifier.EndTable();
        }
    };

    struct PropSetBuilder
    {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_id(flatbuffers::Offset<flatbuffers::String> id) { fbb_.AddOffset(PropSet::VT_ID, id); }
        void add_x(int32_t x) { fbb_.AddElement<int32_t>(PropSet::VT_X, x, 0); }
        void add_y(int32_t y) { fbb_.AddElement<int32_t>(PropSet::VT_Y, y, 0); }
        void add_type(PropType type) { fbb_.AddElement<int8_t>(PropSet::VT_TYPE, static_cast<int8_t>(type), 0); }
        PropSetBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
        PropSetBuilder &operator=(const PropSetBuilder &);
        flatbuffers::Offset<PropSet> Finish()
        {
            auto o = flatbuffers::Offset<PropSet>(fbb_.EndTable(start_, 4));
            return o;
        }
    };

    inline flatbuffers::Offset<PropSet> CreatePropSet(flatbuffers::FlatBufferBuilder &_fbb,
        flatbuffers::Offset<flatbuffers::String> id = 0,
        int32_t x = 0,
        int32_t y = 0,
        PropType type = PropType_NONE)
    {
        PropSetBuilder builder_(_fbb);
        builder_.add_y(y);
        builder_.add_x(x);
        builder_.add_id(id);
        builder_.add_type(type);
        return builder_.Finish();
    }

    inline flatbuffers::Offset<PropSet> CreatePropSetDirect(flatbuffers::FlatBufferBuilder &_fbb,
        const char *id = nullptr,
        int32_t x = 0,
        int32_t y = 0,
        PropType type = PropType_NONE)
    {
        return CreatePropSet(_fbb, id ? _fbb.CreateString(id) : 0, x, y, type);
    }

    struct PlayerEatProp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
    {
        enum
        {
            VT_PLAYER_ID = 4,
            VT_BUBBLE_ID = 6
        };
        const flatbuffers::String *player_id() const { return GetPointer<const flatbuffers::String *>(VT_PLAYER_ID); }
        const flatbuffers::String *bubble_id() const { return GetPointer<const flatbuffers::String *>(VT_BUBBLE_ID); }
        bool Verify(flatbuffers::Verifier &verifier) const
        {
            return VerifyTableStart(verifier) &&
                VerifyField<flatbuffers::uoffset_t>(verifier, VT_PLAYER_ID) &&
                verifier.Verify(player_id()) &&
                VerifyField<flatbuffers::uoffset_t>(verifier, VT_BUBBLE_ID) &&
                verifier.Verify(bubble_id()) &&
                verifier.EndTable();
        }
    };

    struct PlayerEatPropBuilder
    {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_player_id(flatbuffers::Offset<flatbuffers::String> player_id) { fbb_.AddOffset(PlayerEatProp::VT_PLAYER_ID, player_id); }
        void add_bubble_id(flatbuffers::Offset<flatbuffers::String> bubble_id) { fbb_.AddOffset(PlayerEatProp::VT_BUBBLE_ID, bubble_id); }
        PlayerEatPropBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
        PlayerEatPropBuilder &operator=(const PlayerEatPropBuilder &);
        flatbuffers::Offset<PlayerEatProp> Finish()
        {
            auto o = flatbuffers::Offset<PlayerEatProp>(fbb_.EndTable(start_, 2));
            return o;
        }
    };

    inline flatbuffers::Offset<PlayerEatProp> CreatePlayerEatProp(flatbuffers::FlatBufferBuilder &_fbb,
        flatbuffers::Offset<flatbuffers::String> player_id = 0,
        flatbuffers::Offset<flatbuffers::String> bubble_id = 0)
    {
        PlayerEatPropBuilder builder_(_fbb);
        builder_.add_bubble_id(bubble_id);
        builder_.add_player_id(player_id);
        return builder_.Finish();
    }

    inline flatbuffers::Offset<PlayerEatProp> CreatePlayerEatPropDirect(flatbuffers::FlatBufferBuilder &_fbb,
        const char *player_id = nullptr,
        const char *bubble_id = nullptr)
    {
        return CreatePlayerEatProp(_fbb, player_id ? _fbb.CreateString(player_id) : 0, bubble_id ? _fbb.CreateString(bubble_id) : 0);
    }

    struct PlayerAttrChange FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
    {
        enum
        {
            VT_ID = 4,
            VT_SPEED = 6,
            VT_DAMAGE = 8,
            VT_MAXBUBBLE = 10,
            VT_CURRENTBUBBLE = 12
        };
        const flatbuffers::String *id() const { return GetPointer<const flatbuffers::String *>(VT_ID); }
        uint8_t speed() const { return GetField<uint8_t>(VT_SPEED, 0); }
        uint8_t damage() const { return GetField<uint8_t>(VT_DAMAGE, 0); }
        uint8_t maxBubble() const { return GetField<uint8_t>(VT_MAXBUBBLE, 0); }
        uint8_t currentBubble() const { return GetField<uint8_t>(VT_CURRENTBUBBLE, 0); }
        bool Verify(flatbuffers::Verifier &verifier) const
        {
            return VerifyTableStart(verifier) &&
                VerifyField<flatbuffers::uoffset_t>(verifier, VT_ID) &&
                verifier.Verify(id()) &&
                VerifyField<uint8_t>(verifier, VT_SPEED) &&
                VerifyField<uint8_t>(verifier, VT_DAMAGE) &&
                VerifyField<uint8_t>(verifier, VT_MAXBUBBLE) &&
                VerifyField<uint8_t>(verifier, VT_CURRENTBUBBLE) &&
                verifier.EndTable();
        }
    };

    struct PlayerAttrChangeBuilder
    {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_id(flatbuffers::Offset<flatbuffers::String> id) { fbb_.AddOffset(PlayerAttrChange::VT_ID, id); }
        void add_speed(uint8_t speed) { fbb_.AddElement<uint8_t>(PlayerAttrChange::VT_SPEED, speed, 0); }
        void add_damage(uint8_t damage) { fbb_.AddElement<uint8_t>(PlayerAttrChange::VT_DAMAGE, damage, 0); }
        void add_maxBubble(uint8_t maxBubble) { fbb_.AddElement<uint8_t>(PlayerAttrChange::VT_MAXBUBBLE, maxBubble, 0); }
        void add_currentBubble(uint8_t currentBubble) { fbb_.AddElement<uint8_t>(PlayerAttrChange::VT_CURRENTBUBBLE, currentBubble, 0); }
        PlayerAttrChangeBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
        PlayerAttrChangeBuilder &operator=(const PlayerAttrChangeBuilder &);
        flatbuffers::Offset<PlayerAttrChange> Finish()
        {
            auto o = flatbuffers::Offset<PlayerAttrChange>(fbb_.EndTable(start_, 5));
            return o;
        }
    };

    inline flatbuffers::Offset<PlayerAttrChange> CreatePlayerAttrChange(flatbuffers::FlatBufferBuilder &_fbb,
        flatbuffers::Offset<flatbuffers::String> id = 0,
        uint8_t speed = 0,
        uint8_t damage = 0,
        uint8_t maxBubble = 0,
        uint8_t currentBubble = 0)
    {
        PlayerAttrChangeBuilder builder_(_fbb);
        builder_.add_id(id);
        builder_.add_currentBubble(currentBubble);
        builder_.add_maxBubble(maxBubble);
        builder_.add_damage(damage);
        builder_.add_speed(speed);
        return builder_.Finish();
    }

    inline flatbuffers::Offset<PlayerAttrChange> CreatePlayerAttrChangeDirect(flatbuffers::FlatBufferBuilder &_fbb,
        const char *id = nullptr,
        uint8_t speed = 0,
        uint8_t damage = 0,
        uint8_t maxBubble = 0,
        uint8_t currentBubble = 0)
    {
        return CreatePlayerAttrChange(_fbb, id ? _fbb.CreateString(id) : 0, speed, damage, maxBubble, currentBubble);
    }

    struct PlayerStatusChange FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
    {
        enum
        {
            VT_ID = 4,
            VT_STATUS = 6
        };
        const flatbuffers::String *id() const { return GetPointer<const flatbuffers::String *>(VT_ID); }
        PlayerStatus status() const { return static_cast<PlayerStatus>(GetField<int8_t>(VT_STATUS, 0)); }
        bool Verify(flatbuffers::Verifier &verifier) const
        {
            return VerifyTableStart(verifier) &&
                VerifyField<flatbuffers::uoffset_t>(verifier, VT_ID) &&
                verifier.Verify(id()) &&
                VerifyField<int8_t>(verifier, VT_STATUS) &&
                verifier.EndTable();
        }
    };

    struct PlayerStatusChangeBuilder
    {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_id(flatbuffers::Offset<flatbuffers::String> id) { fbb_.AddOffset(PlayerStatusChange::VT_ID, id); }
        void add_status(PlayerStatus status) { fbb_.AddElement<int8_t>(PlayerStatusChange::VT_STATUS, static_cast<int8_t>(status), 0); }
        PlayerStatusChangeBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
        PlayerStatusChangeBuilder &operator=(const PlayerStatusChangeBuilder &);
        flatbuffers::Offset<PlayerStatusChange> Finish()
        {
            auto o = flatbuffers::Offset<PlayerStatusChange>(fbb_.EndTable(start_, 2));
            return o;
        }
    };

    inline flatbuffers::Offset<PlayerStatusChange> CreatePlayerStatusChange(flatbuffers::FlatBufferBuilder &_fbb,
        flatbuffers::Offset<flatbuffers::String> id = 0,
        PlayerStatus status = PlayerStatus_FREE)
    {
        PlayerStatusChangeBuilder builder_(_fbb);
        builder_.add_id(id);
        builder_.add_status(status);
        return builder_.Finish();
    }

    inline flatbuffers::Offset<PlayerStatusChange> CreatePlayerStatusChangeDirect(flatbuffers::FlatBufferBuilder &_fbb,
        const char *id = nullptr,
        PlayerStatus status = PlayerStatus_FREE)
    {
        return CreatePlayerStatusChange(_fbb, id ? _fbb.CreateString(id) : 0, status);
    }

    struct GameStatusChange FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
    {
        enum
        {
            VT_STATUS = 4
        };
        GameStatus status() const { return static_cast<GameStatus>(GetField<int8_t>(VT_STATUS, 0)); }
        bool Verify(flatbuffers::Verifier &verifier) const
        {
            return VerifyTableStart(verifier) &&
                VerifyField<int8_t>(verifier, VT_STATUS) &&
                verifier.EndTable();
        }
    };

    struct GameStatusChangeBuilder
    {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_status(GameStatus status) { fbb_.AddElement<int8_t>(GameStatusChange::VT_STATUS, static_cast<int8_t>(status), 0); }
        GameStatusChangeBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
        GameStatusChangeBuilder &operator=(const GameStatusChangeBuilder &);
        flatbuffers::Offset<GameStatusChange> Finish()
        {
            auto o = flatbuffers::Offset<GameStatusChange>(fbb_.EndTable(start_, 1));
            return o;
        }
    };

    inline flatbuffers::Offset<GameStatusChange> CreateGameStatusChange(flatbuffers::FlatBufferBuilder &_fbb,
        GameStatus status = GameStatus_WAITING)
    {
        GameStatusChangeBuilder builder_(_fbb);
        builder_.add_status(status);
        return builder_.Finish();
    }

    struct Msg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
    {
        enum
        {
            VT_DATA_TYPE = 4,
            VT_DATA = 6
        };
        MsgType data_type() const { return static_cast<MsgType>(GetField<uint8_t>(VT_DATA_TYPE, 0)); }
        const void *data() const { return GetPointer<const void *>(VT_DATA); }
        bool Verify(flatbuffers::Verifier &verifier) const
        {
            return VerifyTableStart(verifier) &&
                VerifyField<uint8_t>(verifier, VT_DATA_TYPE) &&
                VerifyField<flatbuffers::uoffset_t>(verifier, VT_DATA) &&
                VerifyMsgType(verifier, data(), data_type()) &&
                verifier.EndTable();
        }
    };

    struct MsgBuilder
    {
        flatbuffers::FlatBufferBuilder &fbb_;
        flatbuffers::uoffset_t start_;
        void add_data_type(MsgType data_type) { fbb_.AddElement<uint8_t>(Msg::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0); }
        void add_data(flatbuffers::Offset<void> data) { fbb_.AddOffset(Msg::VT_DATA, data); }
        MsgBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
        MsgBuilder &operator=(const MsgBuilder &);
        flatbuffers::Offset<Msg> Finish()
        {
            auto o = flatbuffers::Offset<Msg>(fbb_.EndTable(start_, 2));
            return o;
        }
    };

    inline flatbuffers::Offset<Msg> CreateMsg(flatbuffers::FlatBufferBuilder &_fbb,
        MsgType data_type = MsgType_NONE,
        flatbuffers::Offset<void> data = 0)
    {
        MsgBuilder builder_(_fbb);
        builder_.add_data(data);
        builder_.add_data_type(data_type);
        return builder_.Finish();
    }

    inline bool VerifyMsgType(flatbuffers::Verifier &verifier, const void *union_obj, MsgType type)
    {
        switch (type)
        {
        case MsgType_NONE: return true;
        case MsgType_Welcome: return verifier.VerifyTable(reinterpret_cast<const Welcome *>(union_obj));
        case MsgType_GotIt: return verifier.VerifyTable(reinterpret_cast<const GotIt *>(union_obj));
        case MsgType_JoinRoom: return verifier.VerifyTable(reinterpret_cast<const JoinRoom *>(union_obj));
        case MsgType_RoomInfoUpdate: return verifier.VerifyTable(reinterpret_cast<const RoomInfoUpdate *>(union_obj));
        case MsgType_UserChangeRole: return verifier.VerifyTable(reinterpret_cast<const UserChangeRole *>(union_obj));
        case MsgType_UserChangeStats: return verifier.VerifyTable(reinterpret_cast<const UserChangeStats *>(union_obj));
        case MsgType_GameInit: return verifier.VerifyTable(reinterpret_cast<const GameInit *>(union_obj));
        case MsgType_PlayerPosChange: return verifier.VerifyTable(reinterpret_cast<const PlayerPosChange *>(union_obj));
        case MsgType_PlayerSetBubble: return verifier.VerifyTable(reinterpret_cast<const PlayerSetBubble *>(union_obj));
        case MsgType_BubbleSet: return verifier.VerifyTable(reinterpret_cast<const BubbleSet *>(union_obj));
        case MsgType_BubbleBoom: return verifier.VerifyTable(reinterpret_cast<const BubbleBoom *>(union_obj));
        case MsgType_PropSet: return verifier.VerifyTable(reinterpret_cast<const PropSet *>(union_obj));
        case MsgType_PlayerEatProp: return verifier.VerifyTable(reinterpret_cast<const PlayerEatProp *>(union_obj));
        case MsgType_PlayerAttrChange: return verifier.VerifyTable(reinterpret_cast<const PlayerAttrChange *>(union_obj));
        case MsgType_PlayerStatusChange: return verifier.VerifyTable(reinterpret_cast<const PlayerStatusChange *>(union_obj));
        case MsgType_GameStatusChange: return verifier.VerifyTable(reinterpret_cast<const GameStatusChange *>(union_obj));
        default: return false;
        }
    }

    inline const API::Msg *GetMsg(const void *buf)
    {
        return flatbuffers::GetRoot<API::Msg>(buf);
    }

    inline bool VerifyMsgBuffer(flatbuffers::Verifier &verifier)
    {
        return verifier.VerifyBuffer<API::Msg>(nullptr);
    }

    inline void FinishMsgBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<API::Msg> root)
    {
        fbb.Finish(root);
    }

}  // namespace API

#endif  // FLATBUFFERS_GENERATED_API_API_H_
